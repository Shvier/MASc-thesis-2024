% !TEX root = ../main.tex

\section{Introduction}

\subsection{Motivation}

When the Bitcoin exchange Mt. Gox was declared bankrupt in 2014, a curious fact was reported in the \textit{New York Times}---the missing 744K BTC ``had gone unnoticed for years.'' This led the Bitcoin community to propose that exchanges undergo regular financial audits, with proposals ranging from traditional audits conducted by specialists to completely disintermediated ``crypto-audits'' done directly by the exchange to its users using cryptography. Academics quickly showed these can be done in strict zero-knowledge~\cite{provisions}, and generated a stream of research papers that continues to improve efficiency~\cite{bulletproofs,zeroledge,dapol,spp,notus,izpr} and examine the correctness of deployed proofs~\cite{broken}. Despite these efforts, exchanges are not legally required to use a proof of solvency in jurisdictions today, with some exchanges opting to do them anyways and many not. Meanwhile, many other exchanges have failed in similar ways to Mt. Gox (whether by incompetence or fraud), including higher profile cases like QuadrigaCX and FTX. We argue that proofs of solvency are not perfect but do provide meaningful barriers (or friction) to fraud and incompetence. As academics, we believe we should continue refining these proofs toward practical implementation.  

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{Contributions}

A proof of solvency (or proof of reserves) is a zero-knowledge proof conducted by centralized cryptocurrency exchange (or more generally, any custodian of cryptocurrencies) to offer evidence that the exchange owns enough cryptocurrency to settle each of its users balances. The zero-knowledge component protects the exchange's proprietary information such as: number of users, balances of individual users, total balance of all users, which cryptocurrency addresses belong to the exchange, and total amount of cryptocurrency owned by the exchange. The proof itself is broken into sub-components: ($\pi_\mathsf{keys}$) a proof of knowledge of private signing keys associated with public cryptocurrency addresses (hidden in a freely-composable anonymity set of addresses not belonging to the exchange); ($\pi_\mathsf{assets}$) a summation of these assets into the total assets; ($\pi_\mathsf{user}$) an individualized proof given to each user asserting their balance as used in the overall proof; ($\pi_\mathsf{liabilities}$) a summation of these individual liabilities into the total liabilities; and ($\pi_\mathsf{solvency}$) a demonstration that the subtraction of total liabilities from the total assets is at least 0.

In our paper, we examine the extent to which these sub-components can be made succinct. In particular, we are interested in constant-sized arguments\footnote{We abuse terminology and generally do not distinguish between `proofs' and `arguments,' using the term `proofs' for both. Proofs provide soundness against unbounded malicious provers, while arguments provide zero knowledge against unbounded malicious verifiers. \Sys is a hybrid.} and constant-time verification. This is possible for general arithmetic circuits in the polynomial interactive oracle proof (Poly-IOP) model using protocols like Plonk and its variants. In reference to the ``towards'' in the title of our paper, we are not able to make each sub-component fully succinct, however we make progress as follows: ($\pi_\mathsf{assets}$,$\pi_\mathsf{user}$,$\pi_\mathsf{solvency}$) are constant in size and time (once all public inputs have been interpolated into polynomials by the verifier); ($\pi_\mathsf{keys}$) is linear in the number of addresses in the anonymity set (but is pre-computation that can be re-used when proofs are issued each day); ($\pi_\mathsf{liabilities}$) is linear in the number of bits used to represent each account balance (\eg 32 bits) and is independent of the number of users (technically there is an upper-bound, but it is beyond the reasonable size of the largest exchange).

Our contributions can be summarized as:

\begin{itemize}
\item \Sys:\footnote{Folklore creature revered in ancient Chinese culture for its ability to distinguish truth from deceit.} A mostly succinct protocol that covers every step of the proof, where each sub-component of the proof works with each other sub-component.
\item A novel technique for mapping knowledge of private keys of common blockchains, such as Bitcoin and Ethereum, from their group (\secp) into a pairing-friendly group (\bls) used for succinct arguments.
\item Practical adjustments to the protocol to account for concrete parameters, such as the maximum root of unity in \bls. 
\item Proof of concept implementation of \Sys with performance experimentation.
\end{itemize}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{Limitations}

We do not argue that a proof of solvency is a silver bullet that prevents all fraud and insolvency. However we do believe it can meaningfully raise the bar for incompetence and fraud within an exchange, while providing a trail of records useful during a financial audit or enforcement action. Limitations of \Sys include: 

\begin{itemize}
\item Our protocol relies on a trusted setup. However the setup is universal (shareable with other zk-SNARK systems) and is secure with one honest participant in a decentralized computation of it~\cite{tau}.
\item $\pi_\mathsf{keys}$ assumes the public key (as opposed to only its hash) associated with every address in an anonymity set of keys is known. In Bitcoin and Ethereum, this (typically) corresponds to the address having originated at least one transaction. 
\item $\pi_\mathsf{keys}$ assumes funds are controlled by a single public key. We do not explore how to handle multisig, wallets, Gnosis Safe, \etc However we can support tokens (\eg ERC20, ERC721,\etc) given the mapping between balances and public keys is on-chain, and we can support such assets split across layer two solutions or EVM-chains. 
\end{itemize}

Limitations of proofs of solvency in general (not specific to \Sys) include:

\begin{itemize}
\item Proofs of solvency rely on human behaviour. It needs to be unpredictable to the exchange which users will check and report inconsistencies.
\item Proofs of solvency are a detection mechanism, not a prevention mechanism. Proofs do not help prevent hacks or exit scams. However they greatly complicate cover-ups by the exchange after fraud or a loss of funds has occured.
\item Collusion between parties to pool assets can enable an insolvent exchange to pass a proof of solvency. However the exchange is forced in this case to proactively seek and implement collusion, which raises the chances of discovery. It also goes to motive for fraud (many bankrupt exchanges argue they were just incompetent and it is difficult to distinguish). 
\item Trusted execution environments (TEEs) can reduce trust amongst colluders by sharing the ability to prove ownership without sharing the key itself. However we can adapt $\pi_\mathsf{keys}$ (the $\Sigma$-protocol inside it) for complete knowledge~\cite{completeknowledge}.
\item Demonstrably holding cryptocurrencies in an address does not mean the money is unencumbered. For example, it might be in use off-chain as collateral for a loan. 
\end{itemize}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Preliminaries}

\subsection{Accounting Terminology}

Our terminology follows the accounting and auditing literature. A balance sheet consists of liabilities (value owed to others) and assets (value owned). When total asset value is the same or more than total liabilities, the firm is called solvent. The amount by which the assets exceed the liabilities is called capital or equity (depending on context). Some literature prefers the term `proof of reserves' to `proof of solvency.' This terminology is also sound, although it is not always defined correctly: technically a reserve is an asset that cancels out a corresponding liability, both in amount and in type. A firm can be solvent but not have full reserves. Most banks operate this way with cash liabilities, some assets in cash, but most assets in loans and other investments.\footnote{Banks in the United States have reserve requirements while banks elsewhere, \eg Canada, have capital requirements. Capital requirements speak to solvency, while reserve requirements speak to reserve ratios. Banks that underwent the 2008 financial crisis were more robust when they had capital requirements, as opposed to reserve requirements.} Cryptographic protocols in the literature generally assume both liabilities and assets are the same cryptocurrency so exchanges are expected to be both solvent and have full reserves.

\subsection{Related Work}
\label{sec:rw}

\input{sections/tables/comp}

Proofs of solvency began as a discussion on Bitcointalk, where a protocol was developed for an exchange to announce a commitment to a total liability, and offer a Merkle-tree proof to each user that their balance was reflected in this total liability amount. Provisions, a research paper, used homomorphic commitments and $\Sigma$-protocols to add zero-knowledge, plus it added a proof of assets that could be used with the proof of liabilities to prove overall solvency~\cite{provisions}. As Provisions relies heavily on range proofs for liabilities, Bulletproofs can reduce the proof size of Provisions by 300x~\cite{bulletproofs}. Our protocol uses a polynomial-based range proof~\cite{rangeproof} to further reduce proof size and verifier time.

Outside of Provisions, Bulletproofs, and \Sys, the vast majority of work on proofs of solvency have not attempted an end-to-end proof, focusing instead on just the liabilities or just the assets. Why? We hypothesize that the biggest impediment is that Bitcoin and Ethereum assets are controlled by \secp private keys (see Table~\ref{tab:rb1}). Outside of Bulletproofs (based on inner-product arguments that do not require bilinear pairings and thus, can be implemented in \secp), most other approaches to succinctness require a specific cryptographic setting that is not \secp (\ie RSA for accumulators, pairing-based cryptography for zk-SNARKs, and lattices for zk-STARKs). If one only considers liabilities, then this problem does not have to be dealt with.

Circuit-based solutions are feasible but expensive for the prover---the authors of IZPR report about 500K constraints needed per key and proving times in the order of days for an anonymity set of 6000 keys~\cite{izpr}. By contrast, \Sys is a few minutes of work for the prover for 6000 keys. As this part is not-succinct (it is based on $\Sigma$-protocols), the trade-off is that the verifier has to do a few minutes of work as well. In both cases, IZPR and \Sys, this step does not need to be repeated often, only when the exchange wants to introduce new keys holding its assets. It is also important to recognize IZPR can let the exchange add keys it has not used yet to $\pi_{keys}$, further reducing how often this proof needs to be redone. This is a desirable property we are not able to easily achieve in \Sys (in short, it is due to our  use of selector polynomials instead of lookup arguments but future work could explore blending the best properties of \Sys and IZPR). 

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{Cryptographic Background}

\Sys is mostly a zero-knowledge argument that represents vectors of data as univariate polynomials, which are committed to and provided to the verifier. Properties of the vectors are demonstrated by manipulating the polynomials and opening points of the polynomials---a model called a polynomial interactive oracle proof (Poly-IOP). However before encoding the data into polynomials, the exchange will prove ownership of signing keys with a $\Sigma$-protocol.

We assume our protocol works in a finite field of prime order. For simplicity, we use $\prv$ and $\vrf$ to denote the prover and the verifier in an interactive proof system respectively. We use $g_\mathfrak{g}$ to denote a generator in a group $\mathbb{G}_\mathfrak{g}$ while $h_\mathfrak{g}$ is another generator, and no one knows the relative discrete logarithm of these two generators. We use $\gs$ and $\hs$ to denote the two generators in $\mathbb{G}_s$, the \secp group; and we use $\gb$ and $\hb$ to denote the two generators in $\mathbb{G}_b$, the \bls group. If we need to distinguish which group an input to the pairing is from, we use the notations $[x]_1:=g_1^x,[x]_2:=g_2^x$, otherwise elements are  assumed to be in the first group (including $g_b$ and $h_b$). We use $e([x]_1,[x]_2)$ to denote a non-degenerate bilinear pairing. We use $\hash$ to denote a collision-resilient hash function modelled as a random oracle. We use $\ppt$ to represent probabilistic algorithms run in polynomial time.  For vectors, we use an overhead bar, like $\overline{v}$, to denote a vector and brackets to denote the elements in this vector, e.g., $\overline{v}=\tuple{v_1,v_2,\dots}$. We also use a vector at the top right of a variable to indicate this variable belongs to this vector for readability, e.g., $x^{(\overline{v})}$ means $x$ is an element of $\overline{v}$. We may use these two denotations interchangeably. When we say the summation between two vectors $\overline{a},\overline{b}$, the result is a new vector $\overline{c}$ where each element is the summation of the elements from $\overline{a}$ and $\overline{b}$ at the same row.

We refer the reader to the appendix for the following cryptographic primitives: discrete logarithm assumption (Section~\ref{sec:dlp}), Pedersen commitments (Section~\ref{sec:pedersen}), $\Sigma$-protocols (conjunction and disjunction) (Section~\ref{sec:sigma}), KZG polynomial commitments (Section~\ref{sec:pcs}), and roots of unity (Section~\ref{app:rou}). We review two additional primitives here: polynomial-based range proofs and batched KZG commitments with zero-knowledge extension.

\subsubsection{Range proof}
\label{sec:range}

A range proof enables $\prv$ to convince $\vrf$ a value $x$ is in the range $[0,2^k)$ without revealing $x$. Zero-knowledge range proofs (ZKRPs) have three typical approaches: square decomposition, $n$-ary decomposition, and hash chains~\cite{zkrp}. We use the polynomial-based range proof from Boneh \etal~\cite{rangeproof}.
\begin{enumerate}
    \item \textit{Given input $x$, decompose $x$ to a vector of binary digits $\overline{z}=\tuple{z_1,z_2,\dots,z_k}$, so that $x=\sum_{i=0}^{k-1}2^i\cdot{z_i}$} 
    \item \textit{Construct a vector $\overline{x}=\tuple{x_1,x_2,\dots,x_k}$ such that}
    \begin{align*}
        x_1&=x \\
        x_k&=z_k \\
        x_i&=2x_{i+1}+z_i,i\in[1,k-1]
    \end{align*}
    \item \textit{Interpolate a polynomial $f$ from $\overline{x}$ over a finite field $H$ of order $n$ with elements $\omega^0,\omega^1,\omega^2,\ldots$ (see Appendix~\ref{app:rou})} 
    \item \textit{Prove the following polynomials are vanishing in $H$}
    \begin{align*}
        w_1&:=[f(X)-x]\cdot\frac{X^n-1}{X-\omega^0} \\
        w_2&:=f(X)\cdot[f(X)-1]\cdot\frac{X^n-1}{X-\omega^{n-1}} \\
        w_3&:=[f(X)-2\cdot{f(X\omega)}]\cdot[f(X)-2\cdot{f(X\omega)}-1]\cdot(X-\omega^{n-1})
    \end{align*}
    \begin{enumerate}
        \item $\prv$ \textit{sends the commitment to $f(X)$}
        \item $\vrf$ \textit{sends a random challenge $\gamma$}
        \item $\prv$ \textit{sends the commitment to $q(X)=w/(X^n-1)$, such that}
        \[ w=w_1+\gamma\cdot{w_2}+\gamma^2\cdot{w_3} \]
        \item $\vrf$ \textit{sends a random evaluation point $\zeta\in\mathbb{F}$}
        \item $\prv$ \textit{replies with $f(\zeta),f(\zeta\omega),q(\zeta)$}
        \item $\vrf$ \textit{checks}
        \begin{enumerate}
            \item $w(\zeta)=q(\zeta)\cdot(\zeta^n-1)$
            \item $f(\zeta),f(\zeta\omega),q(\zeta)$ \textit{are the correct evaluations}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

\subsubsection{Batched opening with zero-knowledge extension ($\open$)}
\label{sec:kgzzkp}


To efficiently prove several polynomials are vanishing at several points, there are some batched KZG opening schemes such as the schemes in \cite{plonk,bdfg,fflonk}. Although a PCS does not reveal the committed polynomial directly, it leaks the information of the opening evaluation point. In our scenario, each evaluation is privacy-sensitive so we want to hide the polynomial evaluations. We use the opening scheme from \cite{plonk} and the protocol from \cite{rangeproof} with a zero-knowledge extension to explain how to prove the range-proof polynomials are vanishing efficiently and in zero-knowledge. \\
\textit{Assume $\prv$ is given $x$ and $\vrf$ is given $[x]_1$, $\prv$ wants to prove $x$ is in $[0,2^k)$:}
\begin{enumerate}
    \item $\prv$ \textit{interpolates the polynomial $f$ using the above range proof}
    \item $\prv$ \textit{generates two random numbers $\omega^{\prime},\omega^{\prime\prime}$ in $\mathbb{F}\setminus{H}$ and another two random numbers $\alpha,\beta$ in $\mathbb{F}$}
    \item $\prv$ \textit{interpolates $f^\prime$ at two more points ${\omega^{\prime},\omega^{\prime\prime}}$ such that}
    \[ f^\prime(\omega^{\prime})=\alpha \]
    \[ f^\prime(\omega^{\prime\prime})=\beta \]
    \item $\prv$ \textit{computes $w_1,w_2,$ and $w_3$ in the above range proof and sends the commitment to $f^\prime$,} $\cm_{f^\prime}$
    \item $\vrf$ \textit{sends a random challenge $\gamma\in\mathbb{F}$}
    \item $\prv$ \textit{sends the commitment to $q_w:=w/(X^n-1)$ where}
    \[ w:=w_1+\gamma\cdot{w_2}+\gamma^2\cdot{w_3} \]
    \item $\vrf$ \textit{sends a random evaluation point $\zeta\in\mathbb{F}\setminus{H}$}
    \item $\prv$ \textit{sends the evaluations $f(\zeta),f(\zeta\omega),q_w(\zeta)$}
    \item $\prv$ \textit{sends the commitments to $q_1(X),q_2(X)$, where}
    \[ q_1(X):=\frac{f(X)-f(\zeta)}{X-\zeta}+\gamma\cdot\frac{q_w(X)-q_w(\zeta)}{X-\zeta} \]
    \[ q_2(X):=\frac{f(X)-f(\zeta\omega)}{X-\zeta\omega} \]
    \item $\vrf$ \textit{chooses random $r\in\mathbb{F}$}
    \item $\vrf$ \textit{accepts the proof if and only if}
    \begin{enumerate}
    	\item $w_1(\zeta)+\gamma\cdot{w_2(\zeta)}+\gamma^2\cdot{w_3(\zeta)}=q_w(\zeta)\cdot(\zeta^n-1)$
    	\item $e(F+\zeta\cdot\cm_{q_1}+r\zeta\cdot\cm_{q_2},[1]_2)=e(\cm_{q_1}+r\cdot\cm_{q_2},[x]_2)$\textit{, where}
    	\begin{align*}
    		F:=&\cm_f-[f(\zeta)]_1+\gamma\cdot(\cm_{q_w}-[q_w(\zeta)]_1)da+r\cdot(\cm_f-[f(\zeta\omega)]_1)
    	\end{align*}
    \end{enumerate}
%    \item $\prv$ \textit{interpolates a polynomial $g$ such that $g(\tau)=f(\tau),g(\tau\omega)=f(\tau\omega)$ and sends $g$}
%    \item $\prv$ \textit{sends the commitment to $q_{w^\prime}:=w^\prime/(X^n-1)$, where}
%    \begin{align*}
%    	w^\prime:=&(f(X)-g(X))\cdot\frac{X^n-1}{(X-\tau)(X-\tau\omega)}
%    \end{align*}
%    \item $\vrf$ \textit{sends another random evaluation point $\rho\in\mathbb{F}$}
%    \item $\prv$ \textit{sends the commitment to $q_{\hat{w}}:=\hat{w}/(x-\rho)$, where}
%    \begin{align*}
%    	\hat{w}:=&(f(X)-g(\rho))\cdot\frac{\rho^n-1}{(\rho-\tau)(\rho-\tau\omega)}-q_{w^\prime}(X)\cdot(\rho^n-1)
%    \end{align*}
%    \textit{Note $\hat{w}$ is a zero polynomial for all $x\in\mathbb{F}$, which means $X-\rho$ divides $\hat{w}$}
%    \item $\vrf$ \textit{accepts the proof if and only if}
%    	\begin{enumerate}
%    		\item $w_1(\tau)+\gamma\cdot{w_2(\tau)}+\gamma^2\cdot{w_3(\tau)}=q_w(\tau)\cdot(\tau^n-1)$
%    		\item $g(\tau)=f(\tau),g(\tau\omega)=f(\tau\omega)$
%    		\item \textit{$e(F,[1]_2)=e([q_{\hat{w}}]_1,[x-\rho]_2)$, where}
%	    		\begin{align*}
%	    		F:=&(\cm_f-[g(\rho)]_1)\cdot\frac{\rho^n-1}{(\rho-\tau)(\rho-\tau\omega)}-[q_{\hat{w}}]_1\cdot(\rho^n-1)
%	    		\end{align*}
%    	\end{enumerate}
\end{enumerate}

We prove the protocol has zero knowledge. \\
\textit{Let $\mathcal{S}$ generate $\{\omega_i^\prime,\omega_i^{\prime\prime},\alpha_i,\beta_i\},i\in[0,m]$ and interpolate $\{f_i\}$ such that}
\[ f_i(\omega_i^\prime)=\alpha_i \]
\[ f_i(\omega_i^{\prime\prime})=\beta_i \]
\[ f_i(\omega^i)=0 \]
\textit{where $i\in[0,m]$ and $\omega$ is the root of unity in $H$. Note} $\vrf$ \textit{can interact with $\mathcal{S}$ to execute the protocol and accept the proof from $\mathcal{S}$. Given $\{\omega_i^\prime,\omega_i^{\prime\prime},\alpha_i,\beta_i\}_{i\in[0,m]}$ are chosen uniformly at random each time,} $\vrf$ \textit{cannot distinguish between the transcript from $\mathcal{S}$ and the proof from} $\prv$. \textit{Therefore, the protocol has zero knowledge. We will use} $\open$ \textit{to denote this opening technique.}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Proof of Assets (PoA)}

We will begin on the asset-side of the proof of solvency. To ease the writing, we will take the example of an exchange proving solvency for ETH on Ethereum. The PoA is broken into two steps: \bootstrap and \poa. \bootstrap takes the following public (exchange-chosen) input: a set of Ethereum public keys which consists of its own public keys hidden amongst a larger set of keys belonging to others (\ie an anonymity set which can scale to the full set of public keys on Ethereum); private input: set of private signing keys (in \secp); and outputs `the keys that belong to it.' The exact format of the output can vary; in our case, the input keys are indexed and the output is a binary `selector' vector (in \bls) that records a 0 if the exchange is not claiming to know the secret key and a 1 if the exchange can prove knowledge of the secret key. The main alternative format would be a flat list of the known public keys which can serve as a set for set-membership proofs, which can be performed succinctly with lookup arguments (see IZPR for this approach~\cite{izpr} where it is called `bootstrapping'). Presently, \bootstrap with such an output format is only known to be realizable by general zk-SNARK circuits, whereas we provide direct proof technique for a selector vector output format.

Once the \bootstrap output is provided, \poa takes it as input, along with the current balance of ETH in each address in the anonymity set (publicly known on Ethereum's blockchain). The output is a commitment to the total assets across keys and an argument the total is computed correctly. 

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{The \bootstrap proof}
\input{sections/proofs/01-bootstrap}

Before presenting our \bootstrap proof, we quickly discuss a few approaches that helped us develop it. A highly relevant $\Sigma$-protocol from the literature, COPZ, proves that two commitments in two different groups (\eg \secp and \bls) commit to the same value~\cite{chase22}. The paper cites proof of assets as a use-case but does not work out a protocol. COPZ allows an exchange to `map' private keys from \secp to \bls. Two places this mapping could occur would be at the very start or the very end of the assets proof. At the end, it might look like this: an existing proof of assets protocol (\eg Provisions~\cite{provisions}) could be run to create a commitment to the total assets in \secp, then COPZ can be used to prove the same commitment in \bls, and finally this can be `glued' to a succinct proof of liabilities in \bls. However this does not leverage the fact that \bls might help make the assets proof succinct.

Alternatively, the exchange can map all their keys at the start. There is a roadblock: the exchange can only map keys they know the secret key for and the exchange cannot reveal which keys they know and which they do not. Assume there is a protocol that would allow the exchange to output a sparse vector of \bls private key values (sorted by index of known ETH public keys) containing the key value when they know it, and recording a 0 if they do not. We designed such a protocol only to realize that the key values in \bls are actually never used, we only use the fact that knowledge of them is proven (which is covered by the ability to produce the value in \bls) and the fact that unclaimed keys are zeroed-out. 

This leads to our key observation: we do not need to map \textit{values} from \secp to \bls, we just have to map the \textit{success or failure} of a ZKP in \secp to \bls. This can be accomplished by composing (conjunction and disjunction of) $\Sigma$-protocols. The prover (exchange) will choose set of Ethereum public keys as its anonymity set of size $\kappa$ (containing its actual keys) $\{\mathsf{pk}_1,\mathsf{pk}_2,\dots,\mathsf{pk}_\kappa\}$ and publish them in an ordered (indexed) way. It will also create a binary `selector' array $A_\mathsf{keys}$ with a 1 in the same index of every key it is claiming to know and a 0 in the index of the keys it does not know (or does not want to claim for whatever reason). This vector is interpolated into the evaluation points of a polynomial $P_\mathsf{keys}(X)$  and committed to $C_\mathsf{keys}=\Comm{P_\mathsf{keys}(X)}$ using the KZG polynomial commitment scheme~\cite{kzg}. For each index $i$, the prover shows the evaluation of $P_\mathsf{keys}(X_i)$ but instead of providing the evaluation value ($A_{\mathsf{keys},i}$) in plaintext, it provides a Pedersen commitment to it $\Comm{A_{\mathsf{keys},i}}$ (a mild modification of the KZG showing protocol detailed in Section~\ref{sec:kzgOpenComm}). It then shows the value is correct with the following $\Sigma$-protocol:

\[ \mathrm{ZKPoK} \{ (sk_i,A_{\mathsf{keys},i}) : \Comm{A_{\mathsf{keys},i}}=\Comm{0} \lor [\Comm{A_{\mathsf{keys},i}}=\Comm{1} \land \mathsf{pk}_i=g^{\mathsf{sk}_i} ] \} \]

In plain English, the prover either: (1) puts a 0 in the selector vector; or (2a) puts a 1 in the selection vector \textit{and} (2b) knows the private key of the given public key. (1) and (2b) are a PoK of a representation for Pedersen commitments in \bls while (2b) is a Schnorr PoK of a discrete logarithm in \secp---both well studied $\Sigma$-protocols~\cite{damgard10,sigma}. The fact that (1) and (2b) are in \bls while (2c) is in \secp is not problematic because the disjunction ($\lor$) and conjunction ($\land$) operations for composing $\Sigma$-protocols are based only on how challenge values are constructed and both groups (\secp and \bls) can encode a large $t$-bit challenge (\eg $t=254$) into their exponent groups. 

As this protocol is repeated for each key, it is not succinct and will be $O(\kappa)$ in proof size and verifier time. However once the selector array is proven correct, the exchange can re-use it every time it does a proof of solvency until it updates its keys. The full details are provided in Protocol~\ref{alg:boot}.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{The \poa argument}
\input{sections/proofs/02-assets}

The \bootstrap protocol proves that $\cm_\phi$ is a commitment to a selector polynomial $\phi(X)$ (in \bls) which marks the public keys owned by the exchange. At a given time (block number), the balances of every public key included in the anonymity set will be encoded in polynomial $\delta(X)$. The product of $\phi(X)\cdot\delta(X)$ will preserve the balance values owned by the exchange and zero-out the balance values not claimed by the exchange. The final step is produce a summation over the values in $\phi(X)\cdot\delta(X)$. The exchange will put $\phi(X)\cdot\delta(X)$ in accumulator form $\sigma(X)$ and prove its correctness. In this from, the total assets will sit at the head (first index) of $\sigma(X)$, which is $\sigma(\omega^0)$. The full details are provided in Protocol~\ref{alg:poa}.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Proof of Liabilities}

\subsection{The \pol argument}
\input{sections/proofs/03-liabilities}

The exchange will commit to every user balance and produce a commitment of the total amount across all balances. Since the exchange is free to make-up additional users and include them, we want to make sure this does not help an insolvent exchange in any way. To do this, we force all balances to be zero or positive numbers. For a finite field, this means small integers that have no chance of exceeding the group order (modular reduction) when added together. In practice, we can limit ourselves to an even smaller range that is sufficient to capture what a balance in ETH (or fractions of ETH) might look like. These balances are expressed in binary and we use range proof from Section~\ref{sec:range}.

However when we turn to implement this in practice, we encounter a roadblock. If $\mu$ balances are placed as $k$-bit numbers side-by-side in a vector, we need a vector of size $\mu \cdot k$. If we want to optimize polynomial interpolation, we encode our array at x-coordinates that correspond to the roots of unity of the exponent group (see Appendix~\ref{app:rou}) and for \bls, we can only efficiently encode data vectors of length up to \(2^{32}=4,294,967,296\).\footnote{The exponent group in \bls has 2-adicity of 32.} Consider an exchange with $\mu=1,000,000$ accounts, only 12 bits are left to capture account balances, say, as between 0.01 and 40.96 ETH (\$30 to \$150K USD at time of writing). Exchanges could have more than 1 million accounts, the largest could be more than \$150K USD, and an exchange could have a long tale of accounts with balances less than \$30 such that rounding them all up to \$30 creates a solvency issue. Clearly \(k=2^{32}\) is not large enough for directly encoding liabilities (as binary numbers) into a single polynomial.

To deal with this issue, there are three main alternatives. (1) The exchange can encode points at arbitrary x-coordinates and use general (Laplacian) interpolation, (2) the exchange can break down what it is proving into chunks but this will require one succinct proof per chunk, or (3) the range proof could be adapted for decomposition into something larger than bits (\eg bytes or 32-bit words). The latter may be feasible with lookup arguments, but we do not pursue modifying the range proof~\cite{rangeproof} in this work. Instead we opt for (2). Specifically we will produce a polynomial argument for the first bit of every account, for the second bit of every account, \etc This means \pol will be linear in proof size and verifier work but it is linear in the bit-precision of each account ($k$) and is in fact constant (succinct) in terms of the number of users on the exchange. For example, we will later show if accounts are captured with a precision of 32-bits, the proof size will be under 10KB and verifier time will be under 8ms independent of the number of users on the exchange (see Figure~\ref{fig:pol}).  

The protocol creates $k$ polynomials---the first polynomial $p_1$ for the first bit of each of the $\mu$ accounts, the second polynomial for the second bit of every account, \etc It conducts a range proof `vertically' (across $\{p_1(i), p_2(i), \ldots, p_k(i)\}$ for $\bal_i$) for each account (for all $i$). It then converts the bits into integers `vertically' (across $p_0(i)=\sum_{j=0}^{k-1} 2^j \cdot p_j(i)$)  for each account, creating a polynomial $p_0$ of each user's balance. Last it sums up all elements `horizontally' ($\sum_{i=0}^{\mu-1} p_0(\omega^i)$) in $p_0$ to produce the total liabilities. The bit decomposition is argued with the range proof and the summation of balances is argued with a sum-check. The full protocol is given in Protocol~\ref{alg:pol}. 

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


\subsection{The \userproof argument}
\input{sections/proofs/04-user}

The \userproof argument is conducted between the exchange and the user, so the user can check that their balance is correctly encoded into the polynomials used in \pol. If two users have the same balance, a malicious exchange might include only one of the balances and open up the same balance for each user. Unless if the users compared their proofs, they would not catch the exchange (\cf~\cite{broken}). This attack appears in other cryptographic protocols where users need to check things, the main one being cryptographic voting schemes. It has been studied under general definitions as a `clash attack'~\cite{clash}. The solution is to label each balance with a unique user identifier~\cite{provisions}. Labeling can be done with an additional polynomial of labels under the assumption that a user id and a balance needs to be at the same index. A user id can be the hash of the user's account name or email address.  The full protocol is given in Protocol~\ref{alg:users}.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{The \pos argument}
\input{sections/proofs/05-solvency}

The final step of the proof is prove the total assets exceed the total liabilities. At the end of \poa, total assets contained in the polynomial evaluation point $\sigma(\omega^0)$; while at the end of \pol, the total liabilities are contained in $p_1(\omega^0)$. Assuming assets exceed liabilities by some amount, this amount can be added to the liability-side to provide a difference of exactly zero. The full argument is given in Protocol~\ref{alg:pos}.


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


\section{Security Analysis}
\label{sec:proof}

We adapt the security definition of a zero-knowledge proof of solvency from Provisions~\cite{provisions}. In Appendix~\ref{app:defs}, we recount the definitions and offer a proof sketch for the the main theorem:

\begin{restatable}{theorem}{thmmaster}
\label{thm:master}
\Sys ($\pi_\mathsf{solvency}\leftarrow\langle \pi_\mathsf{keys}, \pi_\mathsf{liabilies}, \pi_\mathsf{assets}, \pi_\mathsf{users} \rangle$) is a privacy-preserving proof of solvency with respect to Definition~\ref{def:2}. 
\end{restatable}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\subsection{Claims}
\label{sec:claims}


\begin{restatable}{theorem}{sigmaclaim}
\label{thm:sigmaclaim}
A $\Sigma$-protocol for relation $\mathrm{ZKPoK} \{ (sk_i,s_i) :  [\mathsf{pk}_i=g^{\mathsf{sk}_i} \land p_i=\Comm{1,r_i}  ] \lor p_i=\Comm{0,r_i} \}$ exists which is complete, has special soundness, and is honest verifier zero-knowledge (HVZK).
\end{restatable}

\begin{proof}

To demonstrate completeness, consult Protocol~\ref{alg:boot} (the inner framed protocol). \\
To demonstrate special soundness, let two accepting conversations between $\prv$ and $\vrf$
$$
(t_1,t_2,t_3,e,e_1,e_2,z_1,z_2,z_3),(t_1,t_2,t_3,e^\prime,e_1^\prime,e_2^\prime,z_1^\prime,z_2^\prime,z_3^\prime)\text{ with $e\ne{e^\prime}$}
$$
be given. It is obivious we can compute $sk_i,s_i$ such that the relation $\mathrm{ZKPoK}(sk_i,s_i)$ exists. Thus the $\Sigma$-protocol for the relation $\mathrm{ZKPoK}$ has special soundness. \\
Honest verifier zero-knowledge (HVZK) is clear: given $e,z_1,z_2,z_3$ at random and choose $e_1,e_2$ such that $e=e_1\oplus{e_2}$, we can make a simulated conversation between the honest verifier and prover using the faking proof tricks. Since $e,z_1,z_2,z_3$ can be chosen freely, the simuated conversation is not distinguishable from the real one.

Since the probability that $s$ is equal to zero or one is exactly the same as the real $\prv$ does, $\vrf$ cannot distinguish the proof produced by $\mathcal{S}$ from the one generated by $\prv$. \end{proof}


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\begin{restatable}{theorem}{nizkclaim}
\label{thm:nizkclaim}
A $\Sigma$-protocol for relation $\mathrm{ZKPoK} \{ (sk_i,s_i) :  [\mathsf{pk}_i=g^{\mathsf{sk}_i} \land p_i=\Comm{1,r_i}  ] \lor p_i=\Comm{0,r_i} \}$ exists which is a non-interactive zero knowledge proof (NIZKP).
\end{restatable}

\begin{proof}
Given the relation can proven with a ``standard'' $\Sigma$-protocol (per Thereom~\ref{thm:sigmaclaim}), we can use the well-known Fiat-Shamir heuristic to compile it to a NIZKP in the random oracle model. We do not repeat the proof for this (see~\cite{damgard10,sigma}) but stress that strong Fiat-Shamir~\cite{weakfs} needs to be used here and in the Poly-IOP components of \Sys, or practical attacks could be leveraged against the system (\cf~\cite{weakfsattacks}).\end{proof}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


\section{Performance Evaluation}

\subsection{Theoretical Performance}

In this section, we anaylze the performance of \Sys, and compare the performance of our work with other prior schemes. Our analysis ignores the relatively trivial cost like Fast Fourier Transform (FFT) and focuses on the heavy work such as multi-scalar multiplication (MSM) and group operations. Our analysis also ignores the differences of the implementations and assumes each protocol is executed in a single thread.
\subsubsection{Proof of Assets}

We use $\kappa$ to denote the size of the anonymity set and we assume $\kappa$ is the power of two for simplicity. The performance analysis of \bootstrap and \userproof are performed as follows:
\begin{itemize}

\item \bootstrap: For each public key in the anonymity set, $\prv$ opens an evaluation of the KZG commitment and generates the corresponding proof of the $\Sigma$-protocol in Protocol~\ref{alg:boot}. When opening an evaluation of a KZG commitment, one MSM for the witness and one MSM for the blinding polynomial are involved. The number of scalar multiplications of the $\Sigma$-protocol is constant. Thus, the overhead proving time of \bootstrap is $O(\kappa^2)$. In terms of verifier's work, $\vrf$ does not need to perform MSM to verify the proofs; $\vrf$ computes scalar multiplications for constant times instead. To verify the committed values are correct, $\vrf$ manipulates the batched KZG scheme rather than verifying each proof one by one, which means $O(1)$ verifying time and proof size for each public key. Therefore, the overhead verifying time and proof size of \bootstrap is $O(\kappa)$.

\item \poa: $\prv$ constructs the accumulator and commits to constant number of polynomials. According to Schwartz-Zippel lemma, $\prv$ only needs to open one point of each polynomial. Thus, the proving time is $O(\kappa)$ and the proof size is $O(1)$ because the number of polynomial commitments is constant. While it takes constant time for $\vrf$ to verify the proof of the PCS, $\vrf$ needs to process the inputs, i.e., interpolates the balances and commits to the balance polynomial, which means one MSM involved. Therefore, the overhead verifier's work of \poa is $O(\kappa)$.

\end{itemize}

\subsubsection{Proof of Liability}
We use $\mu$ to denote the number of users and $k$ to denote the allowed size of the range proof. Recall that $\prv$ needs to construct several polynomials for the range proof. Although the number of the range-proof polynomials is arbitrary, $2^{64}$ is sufficient for almost all the exchanges' requirements in the real world, which means there are less than or equal to 64 polynomials for the range proof. Therefore, we can treat the number of range-proof polynomials as a constant, but we still use $k$ to indicate the performance is related to the range proof. $\prv$ also needs to compute the accumulative polynomial to prove the total liablity is correct, which can be done in linear time. Different from \bootstrap, $\prv$ only opens each polynomial at one random evaluation point. Thus, the proving time is $O(\mu)$.

The verifier's work is broken into \userproof and \pol:
\begin{itemize}

\item \userproof: Each user verifies his balance is the evaluation of the polynomial $p_0$ and his user identifier is the evaluation of the polynomial $u$, and the two evaluation points should be the same. The user checks two proofs of KZG commitment, so the proof size and the verifying time for customers are both $O(1)$.

\item \pol: Auditor verifies the constraints among polynomials $\{p_i\}$ are correct and the committed total liablity is the evaluation of aggregated $p_0$ at $\omega^0$. The verification of constraints requires two steps: 1. validating each opening evaluation is correct; 2. the evaluations of $\{w_1,w_2,w_3,v_1,\dots,v_{m-1}\}$ are zero. The first step can be done in constant time because the number of polynomials is related to the range proof rather than the number of users. The second step takes several scalar multiplications and group additions but still in constant times. Recall that the proof of KZG commitment consists of one witness, one evaluation, and the corresponding evaluation point, which are unrelated to the degree of the polynomial. That means the verifying time and the proof size for auditors are both $O(k)$.

\end{itemize}

\subsubsection{Comparison}

\input{sections/tables/complexity}

In Table~\ref{tab:poa}, we compare this work with other prior PoA schemes. Both IZPR and this work utilize bootstrapping, but the bootstrapping of IZPR will be introduced in their following paper. We only analyze the performance of the bootstrapping for this work. In Table~\ref{tab:pol}, we compare this work with prior PoL schemes.


\subsection{Implementation and Benchmark Methodology}

\input{sections/tables/figures}

To evaluate the performance of \Sys, we implemented our protocols in Rust based on the popular library, arkworks\footnote{\url{https://github.com/arkworks-rs}}. Our implementation is publicly accessible on GitHub\footnote{GitHub: link removed for anonymity. Can supply code via the program chairs as necessary.}. We chose the pairing-friendly elliptic curve \bls for the KZG commitment which has 128 bit security.

Our experiments were conducted on a personal computer with i9-13900KF and 32GB of memory. The experimental data including balances and \secp key pairs are randomly generated locally for simplicity. Since there is no range-proof for PoA, we tested the PoA with balances randomly distributed in $[1,2^{64})$ to simulate the real distrbution of assets, and for PoL, we tested the program with balances randomly distributed in $[1,2^8)$, $[1,2^{16})$, $[1,2^{32})$, and $[1,2^{64})$. We simulated $2^8,2^9\dots,2^{14}$ and $2^{10},2^{11},\dots,2^{20}$ users for PoA and PoL respectively. Simulating different number of users for PoA and PoL is because \bootstrap was time-consuming for larger number of users. For each protocol, we ran the test for ten times with the same experimental data. Our figures are interpolated from the average performance of ten times while discarding the maximum and the minimum samples.

\subsection{Experimental Evaluation}
Figure 2, 3, and 4 reflect the performance of \Sys in single thread with i9-13900KF. We discarded the samples of the maximum and the minimum to calculate the average for each point. The Subfigure (a) of Figure 2 suggests it takes around 600 seconds to generate the proofs for 16,384 keys with i9-13900KF for \bootstrap, and the proof size is 13,893KB. There are around $2^{28}$ unique Ethereum addresses reported by Ethercan.io in May 2024 \footnote{\url{https://etherscan.io/chart/address}}, which means it requires 9,830,400 computing instances to generate the proofs for all the keys in 600 seconds if the exchange wants the maximum anonymous set. It seems impractical for the exchange to depoly such number of servers in the real world. However, recall the exchange only needs to perform \bootstrap once. The exchange can sacrifice the proving time to reduce the number of servers. Moreover, the proving time can be reduced significantly if manipulating more efficient KZG opening schemes. See Section~\ref{sec:opt} for more detailed optimizations. 

Figure 3 shows the proving time and the verifying time are linear in the number of the keys. In our experiments, it takes 433.66 milliseconds to generate the proof and 37.57 milliseconds to verify the proof for 16,384 keys. This suggests the proving time is less than 2 hours if the anonymous set is the whole addresses on Ethereum without any other optimizations! Since the proof size of a KZG commitment is unrelated to the degree of the polynomial (the number of keys), the proof size of \poa is 2KB based on our implementation.

Figure 4 illustrates the performance of our PoL with different number of users and allowed ranges for balance. Our experiments show the proving time grows linearly with the number of users while the verifying time and the proof size are constant. From the test result of Binance's PoL, it needs 1.5 days to generate the proof for 100 million accounts with 100 servers \footnote{\url{https://github.com/binance/zkmerkle-proof-of-solvency/?tab=readme-ov-file}}, but our PoL requires less than 10 minutes with the same number of servers! This indicates our protocol is practical to handle the real-world applications.

\subsection{Optimization}
\label{sec:opt}
Due to the additively homomorphic property of KZG commitment, the prover's work in our protocols can be easily splitted to arbitrary number of servers, and there is no need to provide extra proofs to aggregate the proofs from different servers (provers). That means the proving time will decrease with the growing number of servers. This is the most direct method to make the protocols more efficient. Another way to improve the performance without adding more servers is utilizing more efficient KZG opening schemes. Recall the heaviest work of \bootstrap is proving each committed point is correct, and the opening scheme we demonstrated from Plonk requires $t\cdot{d}$ scalar multiplications for prover, where $t$ is the number of the opening points and $d$ is the degree bound of the polynomial. The work in BDFG20~\cite{bdfg} can reduce this complexity to $2n$ scalar multiplications, which means the dominating complexity will become $O(n)$ rather than $O(n^2)$. The aggreation slightly increases the verifier's work but the extra cost is trivial because of the succinctness of KZG commitment scheme. These optimizations can be applied to both of our PoA and PoL. Moreover, the proof length for multiple points of the KZG commitment will also be decreased to $O(1)$ if BDFG20 is intergated, but the total proof length is still $O(n)$ because of the proof of the $\Sigma$-protocol.



% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


\section{Open Research Challenges}

We presented \Sys as a Poly-IOP solvency argument. The efficiency and succinctness of \Sys might be further improved using advances in other poly-iop systems: lookup arguments and multivariate polynomials (and corresponding commitment schemes). Techniques from recursive SNARKs might enable solvency proofs that are repeated (say every day) to reduce prover time by ignoring ETH addresses and user balances that did not change across the day, while still allowing a verifier to have full confidence in the history of the exchange if they only check the most recent proof. If blockchains like Ethereum add low-gas cost support for \bls, a topic of discussion (EIP-2537\footnote{\url{https://eips.ethereum.org/EIPS/eip-2537}}), verifying proofs of solvency could move on-chain. If an exchange fails to provide a smart contract with a proof of solvency in a timely fashion, the smart contract could be called to trigger penalties or other actions. 

Standardization work could also be useful for proofs of solvency. Of the exchanges that opt into providing proofs of solvency, the exact protocol can vary from other exchanges, and it is not always deployed correctly (at least initially)~\cite{broken}. Having the community coalesce behind a proof template, working out every detail, with audited and formally verified reference code could be helpful to exchanges. \Sys is a good start as it is a complete end-to-end proof system, and is competitive in prover time, verifier time and proof size with other sub-components introduced in the literature.

 
% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\paragraph{Scope.} 
Blah blah blah.

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\paragraph{Contributions.} 
Our primary contributions are as follows.

\begin{enumerate}

\item Blah blah blah.

\item Blah blah blah. 

\item Blah blah blah. 

\end{enumerate}

