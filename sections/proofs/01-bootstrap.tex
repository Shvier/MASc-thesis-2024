% !TEX root = ../../main.tex

\begin{Protocol*}[t!]
    \begin{framed}
    \footnotesize
    \begin{enumerate}
    \item $\prv$ publishes an anonymity set of public keys: $\tuple{\mathsf{pk}_1,\mathsf{pk}_2,\mathsf{pk}_3,\dots,\mathsf{pk}_n}$.
    \item $\prv$ constructs a selector vector: $\overline{s}=\tuple{s_1,s_2,s_3,\ldots,s_n}$ where $s_i=0$ unless $\prv$ can prove knowledge of $\mathsf{sk}_i$ given $\mathsf{pk}_i=\gs^{\mathsf{sk}_i}$, then  $s_i=1$.
    \item $\prv$ interpolates a polynomial from $\overline{s}$, denoted by $\phi(X)$, and commits to $\phi(X)$
    \begin{enumerate}
        \item $\prv$ computes the KZG polynomial commitment to $\phi$. Specifically, $\prv$ constructs a random polynomial $\hat\phi(X)$ and publishes the polynomial commitment $\cm_\phi$ such that $\cm_\phi=\gb^{\phi(\tau)}\hb^{\hat\phi(\tau)}$.
        \item For each $i$, $\prv$ opens the committed evaluation through \textbf{openToCommit} (see Section~\ref{sec:kzgOpenComm}) of $\phi$: $p_i=\gb^{\phi(i)}\hb^{\hat\phi(i)}$.
        \item $\prv$ publishes the witness for each evaluation, $\{w_i\}$.
        \item $\vrf$ verifies $\{p_i\}$ are the evaluations of $\phi$ by checking $e(\cm_\phi/p_i, [1]_2)=e(w_i, [\tau-i]_2)$.
    \end{enumerate}
    \item For each $i$, $\prv$ and $\vrf$ run $\mathrm{ZKPoK} \{ (sk_i,s_i) :  [\mathsf{pk}_i=g^{\mathsf{sk}_i} \land p_i=\Comm{1,r_i}  ] \lor p_i=\Comm{0,r_i} \}$ as follows:
    
    \begin{enumerate}   
    \begin{framed}
        \item Case 1: $s_i=1$ ($\prv$ claims knowledge of $sk_i$)
        \begin{itemize}  
        \item $\prv$ selects $e_1\stackrel{\$}{\leftarrow} \{0,1\}^t; z_3,\beta\stackrel{\$}{\leftarrow}\mathbb{Z}_b;\alpha\stackrel{\$}{\leftarrow}\mathbb{Z}_s$
        \item $\prv$ publishes  $t_1=\gs^\alpha$
        \item $\prv$ publishes $t_2=\hb^\beta$
        \item $\prv$ publishes  $t_3=\gb^{-e_1}\hb^{z_3-r_ie_1}$
        \item $\vrf$ publishes $t$-bit challenge $e\stackrel{\$}{\leftarrow} \{0,1\}^t$ (or $\prv$ via Fiat-Shamir)
        \item $\prv$ computes $e_0=e\oplus{e_1}$ and publishes $e_0$ and $e_1$
        \item $\prv$ publishes $z_1=e_0\mathsf{sk}_i+\alpha$
        \item $\prv$ publishes $z_2=e_0r_i+\beta$
        \item $\prv$ publishes $z_3$
        \end{itemize}
    
        \item Case 2: $s_i=0$ ($\prv$ does not claim knowledge of $sk_i$)
        \begin{itemize}  
        \item $\prv$ selects $e_0\stackrel{\$}{\leftarrow} \{0,1\}^t;z_1\stackrel{\$}{\leftarrow}\mathbb{Z}_s;z_2,\alpha\stackrel{\$}{\leftarrow}\mathbb{Z}_b$
        \item $\prv$ publishes $t_1=\gs^{z_1}/\mathsf{pk}_i^{e_0}$
        \item $\prv$ publishes $t_2=\gb^{e_0}\hb^{z_2-r_ie_0}$
        \item $\prv$ publishes $t_3=\hb^\alpha$
        \item $\vrf$ publishes $t$-bit challenge $e\stackrel{\$}{\leftarrow} \{0,1\}^t$ (or $\prv$ via Fiat-Shamir)
        \item $\prv$ computes $e_1=e\oplus{e_0}$ and publishes $e_0$ and $e_1$    
        \item $\prv$ publishes $z_1$
        \item $\prv$ publishes $z_2$
        \item $\prv$ publishes $z_3=e_1r_i+\alpha$
        \end{itemize}
    
        \item $\vrf$ checks
        \begin{itemize}
        \item $e=e_0\oplus{e_1}$
        \item $\gs^{z_1}=\mathsf{pk}_i^{e_0}t_1$ 
        \item $\gb^{e_0}\hb^{z_2}=p_i^{e_0}t_2$ 
        \item $\hb^{z_3}=p_i^{e_1}t_3$
        \end{itemize}  
    \end{framed}
    \end{enumerate}
    
    \end{enumerate}
    \normalsize	
    \end{framed}
    \caption{The \bootstrap proof demonstrates that $\phi(X)$ encodes a binary selector vector of the public keys for which the exchange can prove knowledge of the corresponding secret key. \label{alg:boot}}
    \end{Protocol*}
    