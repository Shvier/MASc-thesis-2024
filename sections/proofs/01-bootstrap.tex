% !TEX root = ../../main.tex

\begin{Protocol*}[t!]
\begin{framed}
\footnotesize
\begin{enumerate}
\item $\prv$ publishes an anonymity set of public keys: $\tuple{\mathsf{pk}_1,\mathsf{pk}_2,\mathsf{pk}_3,\dots,\mathsf{pk}_n}$.
\item $\prv$ constructs a selector vector: $\overline{s}=\tuple{s_1,s_2,s_3,\ldots,s_n}$ where $s_i=0$ unless $\prv$ can prove knowledge of $\mathsf{sk}_i$ given $\mathsf{pk}_i=\gs^{\mathsf{sk}_i}$, then  $s_i=1$.
\item $\prv$ publishes individual commitments to $\overline{s}$: $\overline{p}=\tuple{\pb(s_0),\pb(s_1),\pb(s_2),\ldots,\pb(s_i)}$ where  $p_i=\pb(s_i,r_i)=\gb^{s_i}\hb^{r_i}$. (To save a step, the value of $r_i$ will be drawn from step 5(b)).

\item For each $i$, $\prv$ and $\vrf$ run $\mathrm{ZKPoK} \{ (sk_i,s_i) :  [\mathsf{pk}_i=g^{\mathsf{sk}_i} \land p_i=\Comm{1,r_i}  ] \lor p_i=\Comm{0,r_i} \}$ as follows:

\begin{enumerate}   
\begin{framed}

    \item Case 1: $s_i=1$ ($\prv$ claims knowledge of $sk_i$)
    \begin{itemize}  
    \item $\prv$ selects $e_2\stackrel{\$}{\leftarrow} \{0,1\}^t; z_3,\beta\stackrel{\$}{\leftarrow}\mathbb{Z}_b;\alpha\stackrel{\$}{\leftarrow}\mathbb{Z}_s$
    \item $\prv$ publishes  $t_1=\gs^\alpha$
    \item $\prv$ publishes $t_2=\hb^\beta$
    \item $\prv$ publishes  $t_3=\gb^{-e_2}\hb^{z_3-r_ie_2}$
    \item $\vrf$ publishes $t$-bit challenge $e\stackrel{\$}{\leftarrow} \{0,1\}^t$ (or $\prv$ via Fiat-Shamir)
    \item $\prv$ computes $e_1=e\oplus{e_2}$ and publishes $e_1$ and $e_2$
    \item $\prv$ publishes $z_1=e_1\mathsf{sk}_i+\alpha$
    \item $\prv$ publishes $z_2=e_1r_i+\beta$
    \item $\prv$ publishes $z_3$
    \end{itemize}

    \item Case 2: $s_i=0$ ($\prv$ does not claim knowledge of $sk_i$)
    \begin{itemize}  
    \item $\prv$ selects $e_1\stackrel{\$}{\leftarrow} \{0,1\}^t;z_1\stackrel{\$}{\leftarrow}\mathbb{Z}_s;z_2,\alpha\stackrel{\$}{\leftarrow}\mathbb{Z}_b$
    \item $\prv$ publishes $t_1=\gs^{z_1}/\mathsf{pk}_i^{e_1}$
    \item $\prv$ publishes $t_2=\gb^{e_1}\hb^{z_2-r_ie_1}$
    \item $\prv$ publishes $t_3=\hb^\alpha$
    \item $\vrf$ publishes $t$-bit challenge $e\stackrel{\$}{\leftarrow} \{0,1\}^t$ (or $\prv$ via Fiat-Shamir)
    \item $\prv$ computes $e_2=e\oplus{e_1}$ and publishes $e_1$ and $e_2$    
    \item $\prv$ publishes $z_1$
    \item $\prv$ publishes $z_2$
    \item $\prv$ publishes $z_3=e_2r_i+\alpha$
    \end{itemize}

    \item $\vrf$ checks
    \begin{itemize}
    \item $e=e_1\oplus{e_2}$
    \item $\gs^{z_1}=\mathsf{pk}_i^{e_1}t_1$ 
    \item $\gb^{e_1}\hb^{z_2}=p_i^{e_1}t_2$ 
    \item $\hb^{z_3}=p_i^{e_2}t_3$
    \end{itemize}  
\end{framed}
    
\end{enumerate}

\item $\prv$ interpolates a polynomial from $\overline{s}$, denoted by $\phi(X)$ and proves to $\vrf$ that it encodes the same $s_i$ values that $\vrf$ just checked: $\phi(X_i)=s_i=\Open{p_i}$ 
\begin{enumerate}
		
		
		\item $\prv$ computes the KZG polynomial commitment to $\phi$. Specifically, $\prv$ constructs a random polynomial $\hat\phi(X)$ and publishes the polynomial commitment $\cm_\phi$ such that $\cm_\phi=\gb^{\phi(\tau)}\hb^{\hat\phi(\tau)}$
		
		\item For each $i$, $\prv$ opens the committed evaluations (see Section~\ref{sec:kzgOpenComm}) of $\phi$: $\gb^{\phi(i)}\hb^{\hat\phi(i)}$. This value matches $p_i=\gb^{s_i}\hb^{r_i}$ except the $r_i$ term will be different. However by doing these steps (5a-b) before step 3 above, $\prv$ can program $r_i=\hat\phi(i)$ exactly (otherwise a $\Sigma$-protocol can be used to show equivalence).  $\prv$ publishes the witness for each evaluation, $\{w_i\}$
		
		\item $\vrf$ verifies $\{p_i\}$ are the evaluations of $\phi$ by checking $e(\cm_\phi/p_i, [1]_2)=e(w_i, [\tau-i]_2)$
   
\end{enumerate}
\end{enumerate}
\normalsize	
\end{framed}
\caption{The \bootstrap proof demonstrates that $\phi(X)$ encodes a binary selector vector of the public keys for which the exchange can prove knowledge of the corresponding secret key. \label{alg:boot}}
\end{Protocol*}
