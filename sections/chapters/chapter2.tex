\chapter{Preliminaries and Related Work}

\section{Accounting Terminology}

Our terminology follows the accounting and auditing literature. A balance sheet consists of liabilities (value owed to others) and assets (value owned). When total asset value is the same or more than total liabilities, the firm is called solvent. The amount by which the assets exceed the liabilities is called capital or equity (depending on context). Some literature prefers the term `proof of reserves' to `proof of solvency.' This terminology is also sound, although it is not always defined correctly: technically a reserve is an asset that cancels out a corresponding liability, both in amount and in type. A firm can be solvent but not have full reserves. Most banks operate this way with cash liabilities, some assets in cash, but most assets in loans and other investments.\footnote{Banks in the United States have reserve requirements while banks elsewhere, \eg Canada, have capital requirements. Capital requirements speak to solvency, while reserve requirements speak to reserve ratios. Banks that underwent the 2008 financial crisis were more robust when they had capital requirements, as opposed to reserve requirements.} Cryptographic protocols in the literature generally assume both liabilities and assets are the same cryptocurrency so exchanges are expected to be both solvent and have full reserves.

\section{Related Work}
\label{sec:rw}

Proofs of solvency began as a discussion on Bitcointalk, where a protocol was developed for an exchange to announce a commitment to a total liability, and offer a Merkle-tree proof to each user that their balance was reflected in this total liability amount. Provisions, a research paper, used homomorphic commitments and $\Sigma$-protocols to add zero-knowledge, plus it added a proof of assets that could be used with the proof of liabilities to prove overall solvency~\cite{provisions}. As Provisions relies heavily on range proofs for liabilities, Bulletproofs can reduce the proof size of Provisions by 300x~\cite{bulletproofs}. Our protocol uses a polynomial-based range proof~\cite{rangeproof} to further reduce proof size and verifier time.

Outside of Provisions, Bulletproofs, and \Sys, the vast majority of work on proofs of solvency have not attempted an end-to-end proof, focusing instead on just the liabilities or just the assets. Why? We hypothesize that the biggest impediment is that Bitcoin and Ethereum assets are controlled by \secp private keys (see Table~\ref{tab:rb1}). Outside of Bulletproofs (based on inner-product arguments that do not require bilinear pairings and thus, can be implemented in \secp), most other approaches to succinctness require a specific cryptographic setting that is not \secp (\ie RSA for accumulators, pairing-based cryptography for zk-SNARKs, and lattices for zk-STARKs). If one only considers liabilities, then this problem does not have to be dealt with.

Circuit-based solutions are feasible but expensive for the prover---the authors of IZPR report about 500K constraints needed per key and proving times in the order of days for an anonymity set of 6000 keys~\cite{izpr}. By contrast, \Sys is a few minutes of work for the prover for 6000 keys. As this part is not-succinct (it is based on $\Sigma$-protocols), the trade-off is that the verifier has to do a few minutes of work as well. In both cases, IZPR and \Sys, this step does not need to be repeated often, only when the exchange wants to introduce new keys holding its assets. It is also important to recognize IZPR can let the exchange add keys it has not used yet to $\pi_{keys}$, further reducing how often this proof needs to be redone. This is a desirable property we are not able to easily achieve in \Sys (in short, it is due to our  use of selector polynomials instead of lookup arguments but future work could explore blending the best properties of \Sys and IZPR). 

\FloatBarrier
\input{sections/tables/comp}
\FloatBarrier

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Cryptographic Background}

We assume our protocol works on a finite field of prime order. For simplicity, we use $\prv$ and $\vrf$ to denote the prover and the verifier in an interactive proof system respectively. We use $g_\mathfrak{g}$ to denote a generator in a group $\mathbb{G}_\mathfrak{g}$ while $h_\mathfrak{g}$ is another generator, and no one knows the relative discrete logarithm of these two generators. Particularly, we use $\gs$ and $\hs$ to denote the two generators in $\mathbb{G}_s$, the \secp group; and we use $\gb$ and $\hb$ to denote the two generators in $\mathbb{G}_b$, the \bls group. If we need to distinguish which group an input to the pairing is from, we use the notations $[x]_1:=g_1^x,[x]_2:=g_2^x$, otherwise elements are  assumed to be in the first group (including $g_s$ and $g_b$). We use $e([x]_1,[x]_2)$ to denote a non-degenerate bilinear pairing. We use $\hash$ to denote a collision-resilient hash function modelled as a random oracle. We use $\ppt$ to represent probabilistic algorithms run in polynomial time.  For vectors, we use an overhead bar to denote a vector and brackets to denote the elements in this vector, e.g., $\overline{v}=\tuple{v_1,v_2,\dots}$. We also use a vector at the top right of a variable to indicate this variable belongs to this vector for readability, e.g., $x^{(\overline{v})}$ means $x$ is an element of $\overline{v}$.

\subsection{Discrete Logarithm Assumption}
\label{sec:dlp}
The discrete logarithm problem describes, given a triplet $(\mathbb{G}, p, g)$, where $\mathbb{G}$ is a cyclic group of order $p$ generated by $g\in\mathbb{G}$, and an element $y\in\mathbb{G}$, for a given adversary $\mathcal{A}$, $\mathcal{A}$ needs to compute an $x$ such that $y=g^x$. The discrete logarithm assumption holds for $\mathbb{G}$ if it is infeasible for $\mathcal{A}$ to find such $x$ in polynomial time.

\subsection{Pedersen Commitment}
\label{sec:pedersen}
The Pedersen commitment scheme \cite{pedersen} enables $\prv$ to \textit{commit} to a value $x$ without revealing it. Pedersen commitment provides perfectly hiding and computational binding based on the discrete logarithm assumption. Additionally, Pedersen commitments are \textit{additively homomorphic}: given two commitments $\textbf{C}_1$ and $\textbf{C}_2$, the summation of their secrets $x_1$ and $x_2$ is the secret of $\textbf{C}_1\cdot\textbf{C}_2$. We use $\textbf{C}(x)$ to denote a Pedersen commitment to the value $x$. Particularly, we use $\ps$ to denote a Pedersen commitment in \secp and $\pb$ to denote a Pedersen commitment in \bls.

\subsection{$\Sigma$-Protocol}

The $\Sigma-$protocol is a three-move interactive proof system. We define the $\Sigma-$protocol similarly to \cite{damgard10}.
\begin{definition}[$\Sigma$-protocol]
\label{sec:sigma}
Let $R$ be a binary relation between the statement $x$ and the witness $w$. Given common input $x$ to $\prv$\ and $\vrf$, and private input $(x,w)$ such that $(x,w)\in{R}$ to $\prv$, they run the following protocol:
\begin{enumerate}
    \item $\prv$ computes a message $m$ from $(x,w)$ and sends $m$.
    \item $\vrf$ sends a random challenge $c$.
    \item $\prv$ replies with $z$.
\end{enumerate}
At the end of the protocol $\vrf$ has the data $(x,m,c,z)$. He decides to output \textbf{acc} or \textbf{rej}; such that
\begin{itemize}
    \item \textbf{Completeness}: If $\prv$ follows the protocol to generate the message $(m,c,z)$, $\vrf$ always accepts.
    \item \textbf{Special soundness}: If there exists a $\ppt$ extractor $\mathcal{E}$, given any input $x$ and any two accepting $(m,c,z),(m,c^\prime,z^\prime)$ where $c\ne{c^\prime}$, $\mathcal{E}$ can compute $w$ where $(x,w)\in{R}$.
    \item \textbf{HVZK}: If there exists a $\ppt$ simulator $\mathcal{S}$, such that the transcript produced by $\mathcal{S}$ is indistinguishable from the messages between $\prv$ and $\vrf$.
\end{itemize}
\end{definition}
A commonly well-known way to convert a $\Sigma-$protocol into non-interactive is using the Fiat-Shamir transform \cite{fs}. But we still use the standard interactive $\Sigma-$protocol to demonstrate our work for comprehension.

\subsection{Disjunction of $\Sigma$-Protocols (OR Proof)}
The disjunction of $\Sigma$-protocols (OR proof) allows $\prv$ to prove the claimed $x$ is $x_1$ or $x_2$ through a $\Sigma$-protocol. More precisely, given two inputs $x_1,x_2$, $\prv$ proves he knows a $w$ such that $(x_1,w)\in{R_1}$ or $(x_2,w)\in{R_2}$, but $\vrf$ cannot learn which one $\prv$ knows. We use the same definition as \cite{damgard10}.
\begin{definition}[OR Proof]
Let $s$ equal $0$ or $1$. The OR proof is a $\Sigma-$protocol that $\prv$ and $\vrf$ are given two public inputs $x_1,x_2$, and $\prv$ is given $w$ as private input. They run the following protocol:
\begin{enumerate}
    \item $\prv$ computes the message $m_s$ using $(x_s,w)$ as input. \\
    $\prv$ randomly generates $c_{1-s}$ as the challenge for $x_{1-s}$ and runs the simulator $\mathcal{S}(x_{1-s},c_{1-s})$ to produce $(m_{1-s},z_{1-s})$.
    \item $\prv$ sends $m_s$ and $m_{1-s}$.
    \item $\vrf$ sends a master challenge $c$.
    \item $\prv$ computes $c_s=c\oplus{c_{1-s}}$ and $z_s$ on inputs $(x_s,c_s,m_s,w)$. \\
    $\prv$ sends $(c_s,c_{1-s},z_s,z_{1-s})$.
\end{enumerate}
At the end of the protocol $\vrf$ verifies $c=c_s\oplus{c_{1-s}}$ and both $(m_s,c_s,z_s,x_s)$ and $(m_{1-s},c_{1-s},z_{1-s},x_{1-s})$ are valid to output \textbf{acc} or \textbf{rej}; such that
\begin{itemize}
    \item \textbf{Completeness:} The case of $c_{1-s}$ is always accepted by $\vrf$ as the definition of a simulator; on the other side, the case of $c_s$ has no difference from the standard $\Sigma-$protocol.
    \item \textbf{Special soundness:} Let $\prv$ execute the protocol twice. Two accepting transcripts
    \[ (x_s,x_{1-s},c,c_s,c_{1-s},z_s,z_{1-s}),(x_s,x_{1-s},c^\prime,c_s^\prime,c_{1-s}^\prime,z_s^\prime,z_{1-s}^\prime),c\ne{c^\prime} \] 
    are given. It is clear that for some $s=0$ or $1$, the witness $w$ such that $(x_s,w)\in{R}$ can be extracted through an extractor $\mathcal{E}$ by the special soundness of $\Sigma$-protocol.
    \item \textbf{Special HVZK}: Given a master challenge $c$, let $\mathcal{S}$ choose $c_s$ or $c_{1-s}$ randomly and the other will be determined. Then let the simulator run twice: $\mathcal{S}(x_s,c_s),\mathcal{S}(x_{1-s},c_{1-s})$, to output $(m_s,z_s,m_{1-s},z_{1-s})$. The outputs of $\mathcal{S}$ have the same distribution as those of $\prv$.
\end{itemize}
\end{definition}
We use $x={x_1\orproof{x_2}}$ to denote $x$ is $x_1$ or $x_2$.

\subsection{Zero-Knowledge Proofs}
Informally, a zero-knowledge proof is a cryptographic protocol allowing $\prv$ to convince $\vrf$ that the claiming statement is true without revealing additional information, except the fact that the statement's truth. A zero-knowledge proof must satisfy the following properties:
\begin{enumerate}
    \item \textbf{Completeness:} If the statement is true, $\vrf$ will be convinced.
    \item \textbf{Soundness:} If the statement is false, the probability that $\vrf$ is convinced is negligible.
    \item \textbf{Zero-knowledge:} If the statement is true, $\vrf$ learns nothing except the fact that the statement is true.
\end{enumerate}

\begin{definition}[Special Soundness]
For a $\Sigma$-protocol, if the witness $w$ can be extracted from any two accepting conversations on the same input $x$ with the same message but different challenge, we call this special soundness of $\Sigma$-protocol. Particularly, special soundness implies soundness.
\end{definition}

\begin{definition}[Knowledge Soundness in the Algebraic Group Model]
For any algebraic adversary $\mathcal{A}$ in an interactive protocol between $\prv$ and $\vrf$ for a relation $\mathcal{R}$, there exists a $\ppt$ extractor $\mathcal{E}$ given access to $\mathcal{A}$'s messages during the protocol, and $\mathcal{A}$ can win the following game with negligible probability:
\begin{enumerate}
    \item $\mathcal{A}$ chooses input $x$ and outputs the message like $\prv$.
    \item $\mathcal{E}$, given access to $\mathcal{A}$'s outputs from the previous step, outputs the witness $w$.
    \item $\mathcal{A}$ wins if
    \begin{enumerate}
        \item $\vrf$ outputs \textbf{acc} at the end of the protocol, and
        \item $(x,w)\notin\mathcal{R}$.
    \end{enumerate}
\end{enumerate}
\end{definition}

\begin{definition}[Honest Verifier Zero Knowledge]
Honest verifier zero knowledge, or HVZK, is for a $\Sigma$-protocol, if there exists a $\ppt$ simulator $\mathcal{S}$ such that the transcript produced by $\mathcal{S}$ has the same distribution as the transcript of a conversation between the honest $\prv$ and $\vrf$ on the same input.
\end{definition}

\begin{definition}[Special Honest Verifier Zero Knowledge]
Special honset verifier zero knowledge, or special HVZK, is for a $\Sigma$-protocol, if there exists a $\ppt$ simulator such that additionally given the challenge $c$ to $\mathcal{S}$, the transcript produced by $\mathcal{S}$ has the same distribution as the transcript of a conversation between the honest $\prv$ and $\vrf$ on the same input, even if for the case that the witness for the statement does not exist.
\end{definition}

\subsection{Roots of Unity}
\label{app:rou}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{roots}
\caption{Small number ($\mathbb{Z}_{31}$) example of encoding a vector of integers $\tuple{3,1,1,3,7}$ into (a) the first 5 points of a polynomial, and (b) into 5th roots of unity ($\omega=3$).\label{fig:rou}}
\end{figure}

We use the approach of encoding data vectors into polynomials, committing to them using a polynomial commitment scheme (PCS), and forming zero knowledge arguments---a model called a polynomial-based interactive oracle proof (Poly-IOP). The zk-SNARK system Plonk popularized Poly-IOPs and has many extensions and optimizations. A one-dimensional vector of data is encoded into a univariate polynomial using 1 of 3 methods (all 3 are used at different steps of Plonk): (1) into the coefficients of the polynomial, (2) as roots of the polynomial, and (3) as the \(y\)-coordinates (\(\mathsf{data}_i=f(x_i)\)) of points on the polynomial. Plonk mostly relies on (3) and an interpolation algorithm is used to find the corresponding coefficients of the polynomial, which is
needed for the PCS. General interpolation algorithms are \(O(n^2)\) work for \(n\) evaluation points but this can be reduced to \(O(n\log n)\) with an optimization.

The optimization enables interpolation via the fast Fourier transform (FFT). It concerns how to choose the \(x\)-coordinates, which will serve as the index for accessing the data: evaluating \(f(X)\) at \(x_i\) will reveal \(\mathsf{data}_i\). First note, \(x\)-coordinates are from the exponent group (\(\mathbb{Z}_q\)) and the choices exceed what is feasible to use (\(2^{255}\) values in \bls). Any subset can be used and interpolated. The optimization is to chose them with a mathematical structure. Specifically, instead an additive sequence (e.g., \(0,1,2,3,\ldots\)), we use a multiplicative sequence
\(1,\omega,\omega\cdot\omega,\omega\cdot\omega\cdot\omega,\ldots\) or equivalently: \(\omega^0,\omega^1,\omega^2,\ldots,\omega^{\kappa-1}\). Further, the sequence is closed under multiplication which means that next index after \(\omega^{\kappa-1}\) wraps back to the first index: \(\omega^{k-1} \cdot \omega = \omega^\kappa = \omega^0=1\) (this property is also useful in proving relationships between data in the vector and its neighbouring values).

For terminology, we say \(\omega\) is a generator with multiplicative order \(\kappa\) in \(\mathbb{Z}_q\). This implies \(\omega^\kappa=1\). Rearranging, \(\omega=\sqrt[\kappa]{1}\). Thus we can equivalently describe \(\omega\) as a \(\kappa\)-th root of 1. Finally, as 1 is the unity element in \(\mathbb{Z}_q\), \(\omega\) is commonly called a \(\kappa\)-th root of unity.

For practical purposes, \(\kappa\) represents the length of the longest vector of data we can use in our protocol. Where does \(\kappa\) come from? Different elements of \(\mathbb{Z}_q\) will have different multiplicative orders but every order must be a divisor of \(q-1\). Thus \(\kappa\) is the largest divisor of the exact value of \(q\) used in an elliptic curve standard. The value of $q$ in \bls has \(\kappa=2^{32}\) (for terminology, this called a \(2\)-adicity of \(32\)).

\subsection{Polynomial Commitment Scheme}
A polynomial commitment scheme (PCS) allows $\prv$ to commit to a polynomial to convince $\vrf$ that claimed evaluations are of the committed polynomial. Particularly, our protocol requires the scheme uses an extra random polynomial to achieve unconditionally binding, \ie the KZG commitment in Pedersen form. We define the following scheme based on \cite{kzg,plonk,bdfg}.
\begin{definition}[Polynomial Commitment Scheme]
\label{def:pcs}
A polynomial commitment scheme consists of three moves: \textbf{gen}, \textbf{com}, and \textbf{open} such that
\begin{enumerate}
    \item \textbf{gen}$(d)$ is an algorithm that given a random number $\tau\in\mathbb{F}$ and a positive integer d, outputs a structured reference string (SRS) \textbf{srs} such that
    \[ \textbf{srs}=\tuple{g_1,g_1^\tau,\dots,g_1^{\tau^d},h_1,h_1^\tau,\dots,h_1^{\tau^d},g_2,g_2^\tau} \]
    \item \textbf{com}($f$, \textbf{srs}) outputs a commitment $\cm=g_1^{f(\tau)}h_1^{\hat{f}(\tau)}$ to $f$, where $\hat{f}$ is a random polynomial of degree $d$, and $f$ is a polynomial of degree $d$ or less.
    \item \textbf{open} is a protocol that $\prv$ is given input f, and $\prv$ and $\vrf$ are both given
    \begin{itemize}
        \item \textbf{srs}
        \item $\cm$ - the commitment to $f$
        \item $a$ - an evaluation point of $f$
        \item $b$ - the evaluation of $f(a)$
        \item $\hat{b}$ - the evaluation of $\hat{f}(a)$
    \end{itemize}
    \textit{They run the protocol as follows:}
    \begin{enumerate}
        \item $\prv$ computes the witness $w$ for $(a,b,\hat{b})$ such that
        \[ w=g_1^{\psi(\tau)}h_1^{\hat\psi(\tau)} \]
        where $\psi(x)=\frac{f(X)-f(a)}{X-a}$, and $\hat\psi(x)=\frac{\hat{f}(X)-\hat{f}(a)}{X-a}$
        \item $\vrf$ outputs \textbf{acc} if and only if
        \[ e(\cm/(g_1^bh_1^{\hat{b}}),[1]_2)=e(w,[\tau-a]_2) \]
    \end{enumerate}
\end{enumerate}
\begin{itemize}
    \item \textbf{Completeness}: It is clear that $w$ exists if and only if $f(a)=b$ and $\hat{f}(a)=\hat{b}$, which means $\vrf$ always accepts the proof if $\prv$ follows the protocol.
    \item \textbf{Knowledge soundness in the algebraic group model}: For any algebraic adversary $\mathcal{A}$ in an interactive protocol of PCS, there exists a $\ppt$ extractor $\mathcal{E}$ given access to $\mathcal{A}$'s messages during the protocol, and $\mathcal{A}$ can win the following game with negligible probability:
    \begin{enumerate}
        \item Given the inputs that $\prv$ \textit{can access, $\mathcal{A}$ outputs} $\cm$.
        \item $\mathcal{E}$ outputs $f\in\mathbb{F}_{<d}[X]$ from $\mathcal{A}$'s output.
        \item $\mathcal{A}$ generates $w$ and $b^\prime$ at a random evaluation point $a$.
        \item $\mathcal{A}$ wins if
        \begin{itemize}
            \item $\vrf$ accepts the proof at the end of the protocol.
            \item $b^\prime\ne{b}$.
        \end{itemize}
    \end{enumerate}
\end{itemize}
\end{definition}
Our work uses PCS with the roots of unity. We use $\omega$ to denote the roots of unity. We use $\cm_f$ to denote a polynomial commitment to $f$.

\subsection{Polynomial Protocol}
Gabizon \etal~\cite{plonk} introduced the definition of a universal polynomial protocol. Here we describe a variant of it based on KZG commitment scheme for our work.
\begin{definition}[Polynomial Protocol]
Fix positive integer $d,t,l$. Let $i\in[1,l]$. Let $\mathcal{R}\subseteq\mathbb{F}\times\mathbb{F}\times\cdots\times\mathbb{F}$ be a polynomial relation for one or more polynomials. Given a set of polynomials $f_1,f_2,\dots,f_t\in\mathbb{F}_{<d}[X]$ as $\prv$'s private input, and a set of polynomial relations $\mathcal{R}_1,\mathcal{R}_2,\dots,\mathcal{R}_l$ as public input, a polynomial protocol is a three-move protocol that $\prv$ wants to convince $\vrf$ each $\mathcal{R}_i$ holds for the certain set $F_i\subseteq\{f_1,f_2,\dots,f_t\}$. $\prv$ and $\vrf$ runs the protocol as follows.
\begin{enumerate}
    \item $\prv$ commits to $f_1,f_2,\dots,f_t$, and publishes all commitments, $\cm_{f_1},\cm_{f_2},\dots,\cm_{f_t}$.
    \item $\vrf$ sends a random evaluation point as challenge.
    \item $\prv$ responds with the corresponding evaluation and the commitment to the witness at the evaluation point for each polynomial.
\end{enumerate}
At the end of the protocol, $\vrf$ outputs \textbf{acc} or \textbf{rej} by checking
\begin{enumerate}
    \item Each evaluation of $f_1,f_2,\dots,f_t$ at the random point is valid through the KZG checking
    \item Each relation $\mathcal{R}_i$ holds for the prescribed polynomials $F_i$. More precisely, $\vrf$ verifies the evaluations of the polynomials in $F_i$ satisfy the equation defined by $\mathcal{R}_i$, \ie the zero test of polynomials.
\end{enumerate}
A polynomial protocol has the following properties:
\begin{itemize}
    \item \textbf{Completeness:} $\vrf$ always outputs \textbf{acc} if $\prv$ follows the protocol correctly to compute the proof $\pi_i$ for the relation $\mathcal{R}_i$, and $\mathcal{R}_i$ holds for the prescribed polynomials $F_i$, denoted by $(F_i,\pi_i)\in\mathcal{R}_i$.
    \item \textbf{Knowledge soundness in the algebraic group model}: For any algebraic adversary $\mathcal{A}$ in a polynomial protocol, there exists a $\ppt$ extractor $\mathcal{E}$ given access to $\mathcal{A}$'s messages during the protocol, and $\mathcal{A}$ can win the following game with negligible probability:
    \begin{enumerate}
        \item Given the inputs that $\prv$ \textit{can access, $\mathcal{A}$ outputs} $\cm_{f_1},\cm_{f_2},\dots,\cm_{f_t}$.
        \item $\mathcal{E}$ outputs $f_1,f_2,\dots,f_t\in\mathbb{F}_{<d}[X]$ from $\mathcal{A}$'s output and $\{F_i\}$ from these polynomials.
        \item $\mathcal{A}$ outputs the evaluation at the random evaluation point for each polynomial and the corresponding proofs $\{\pi_i\}$.
        \item $\mathcal{A}$ wins if
        \begin{itemize}
            \item $\vrf$ accepts the proof at the end of the protocol.
            \item $(F_i,\pi_i)\notin\mathcal{R}_i$ or any evaluation is not correct.
        \end{itemize}
    \end{enumerate}
\end{itemize}
\end{definition}
