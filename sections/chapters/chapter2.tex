\chapter{Preliminaries}

\section{Accounting Terminology}

Our terminology follows the accounting and auditing literature. A balance sheet consists of liabilities (value owed to others) and assets (value owned). When total asset value is the same or more than total liabilities, the firm is called solvent. The amount by which the assets exceed the liabilities is called capital or equity (depending on context). Some literature prefers the term `proof of reserves' to `proof of solvency.' This terminology is also sound, although it is not always defined correctly: technically a reserve is an asset that cancels out a corresponding liability, both in amount and in type. A firm can be solvent but not have full reserves. Most banks operate this way with cash liabilities, some assets in cash, but most assets in loans and other investments.\footnote{Banks in the United States have reserve requirements while banks elsewhere, \eg Canada, have capital requirements. Capital requirements speak to solvency, while reserve requirements speak to reserve ratios. Banks that underwent the 2008 financial crisis were more robust when they had capital requirements, as opposed to reserve requirements.} Cryptographic protocols in the literature generally assume both liabilities and assets are the same cryptocurrency so exchanges are expected to be both solvent and have full reserves.

\section{Related Work}
\label{sec:rw}

\input{sections/tables/comp}

Proofs of solvency began as a discussion on Bitcointalk, where a protocol was developed for an exchange to announce a commitment to a total liability, and offer a Merkle-tree proof to each user that their balance was reflected in this total liability amount. Provisions, a research paper, used homomorphic commitments and $\Sigma$-protocols to add zero-knowledge, plus it added a proof of assets that could be used with the proof of liabilities to prove overall solvency~\cite{provisions}. As Provisions relies heavily on range proofs for liabilities, Bulletproofs can reduce the proof size of Provisions by 300x~\cite{bulletproofs}. Our protocol uses a polynomial-based range proof~\cite{rangeproof} to further reduce proof size and verifier time.

Outside of Provisions, Bulletproofs, and \Sys, the vast majority of work on proofs of solvency have not attempted an end-to-end proof, focusing instead on just the liabilities or just the assets. Why? We hypothesize that the biggest impediment is that Bitcoin and Ethereum assets are controlled by \secp private keys (see Table~\ref{tab:rb1}). Outside of Bulletproofs (based on inner-product arguments that do not require bilinear pairings and thus, can be implemented in \secp), most other approaches to succinctness require a specific cryptographic setting that is not \secp (\ie RSA for accumulators, pairing-based cryptography for zk-SNARKs, and lattices for zk-STARKs). If one only considers liabilities, then this problem does not have to be dealt with.

Circuit-based solutions are feasible but expensive for the prover---the authors of IZPR report about 500K constraints needed per key and proving times in the order of days for an anonymity set of 6000 keys~\cite{izpr}. By contrast, \Sys is a few minutes of work for the prover for 6000 keys. As this part is not-succinct (it is based on $\Sigma$-protocols), the trade-off is that the verifier has to do a few minutes of work as well. In both cases, IZPR and \Sys, this step does not need to be repeated often, only when the exchange wants to introduce new keys holding its assets. It is also important to recognize IZPR can let the exchange add keys it has not used yet to $\pi_{keys}$, further reducing how often this proof needs to be redone. This is a desirable property we are not able to easily achieve in \Sys (in short, it is due to our  use of selector polynomials instead of lookup arguments but future work could explore blending the best properties of \Sys and IZPR). 

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Cryptographic Background}

\Sys is mostly a zero-knowledge argument that represents vectors of data as univariate polynomials, which are committed to and provided to the verifier. Properties of the vectors are demonstrated by manipulating the polynomials and opening points of the polynomials---a model called a polynomial interactive oracle proof (Poly-IOP). However before encoding the data into polynomials, the exchange will prove ownership of signing keys with a $\Sigma$-protocol.

We assume our protocol works in a finite field of prime order. For simplicity, we use $\prv$ and $\vrf$ to denote the prover and the verifier in an interactive proof system respectively. We use $g_\mathfrak{g}$ to denote a generator in a group $\mathbb{G}_\mathfrak{g}$ while $h_\mathfrak{g}$ is another generator, and no one knows the relative discrete logarithm of these two generators. We use $\gs$ and $\hs$ to denote the two generators in $\mathbb{G}_s$, the \secp group; and we use $\gb$ and $\hb$ to denote the two generators in $\mathbb{G}_b$, the \bls group. If we need to distinguish which group an input to the pairing is from, we use the notations $[x]_1:=g_1^x,[x]_2:=g_2^x$, otherwise elements are  assumed to be in the first group (including $g_b$ and $h_b$). We use $e([x]_1,[x]_2)$ to denote a non-degenerate bilinear pairing. We use $\hash$ to denote a collision-resilient hash function modelled as a random oracle. We use $\ppt$ to represent probabilistic algorithms run in polynomial time.  For vectors, we use an overhead bar, like $\overline{v}$, to denote a vector and brackets to denote the elements in this vector, e.g., $\overline{v}=\tuple{v_1,v_2,\dots}$. We also use a vector at the top right of a variable to indicate this variable belongs to this vector for readability, e.g., $x^{(\overline{v})}$ means $x$ is an element of $\overline{v}$. We may use these two denotations interchangeably. When we say the summation between two vectors $\overline{a},\overline{b}$, the result is a new vector $\overline{c}$ where each element is the summation of the elements from $\overline{a}$ and $\overline{b}$ at the same row.

We refer the reader to the appendix for the following cryptographic primitives: discrete logarithm assumption (Section~\ref{sec:dlp}), Pedersen commitments (Section~\ref{sec:pedersen}), $\Sigma$-protocols (conjunction and disjunction) (Section~\ref{sec:sigma}), KZG polynomial commitments (Section~\ref{sec:pcs}), and roots of unity (Section~\ref{app:rou}). We review two additional primitives here: polynomial-based range proofs and batched KZG commitments with zero-knowledge extension.

\subsection{Range proof}
\label{sec:range}

A range proof enables $\prv$ to convince $\vrf$ a value $x$ is in the range $[0,2^k)$ without revealing $x$. Zero-knowledge range proofs (ZKRPs) have three typical approaches: square decomposition, $n$-ary decomposition, and hash chains~\cite{zkrp}. We use the polynomial-based range proof from Boneh \etal~\cite{rangeproof}.
\begin{enumerate}
    \item \textit{Given input $x$, decompose $x$ to a vector of binary digits $\overline{z}=\tuple{z_1,z_2,\dots,z_k}$, so that $x=\sum_{i=0}^{k-1}2^i\cdot{z_i}$} 
    \item \textit{Construct a vector $\overline{x}=\tuple{x_1,x_2,\dots,x_k}$ such that}
    \begin{align*}
        x_1&=x \\
        x_k&=z_k \\
        x_i&=2x_{i+1}+z_i,i\in[1,k-1]
    \end{align*}
    \item \textit{Interpolate a polynomial $f$ from $\overline{x}$ over a finite field $H$ of order $n$ with elements $\omega^0,\omega^1,\omega^2,\ldots$ (see Appendix~\ref{app:rou})} 
    \item \textit{Prove the following polynomials are vanishing in $H$}
    \begin{align*}
        w_1&:=[f(X)-x]\cdot\frac{X^n-1}{X-\omega^0} \\
        w_2&:=f(X)\cdot[f(X)-1]\cdot\frac{X^n-1}{X-\omega^{n-1}} \\
        w_3&:=[f(X)-2\cdot{f(X\omega)}]\cdot[f(X)-2\cdot{f(X\omega)}-1]\cdot(X-\omega^{n-1})
    \end{align*}
    \begin{enumerate}
        \item $\prv$ \textit{sends the commitment to $f(X)$}
        \item $\vrf$ \textit{sends a random challenge $\gamma$}
        \item $\prv$ \textit{sends the commitment to $q(X)=w/(X^n-1)$, such that}
        \[ w=w_1+\gamma\cdot{w_2}+\gamma^2\cdot{w_3} \]
        \item $\vrf$ \textit{sends a random evaluation point $\zeta\in\mathbb{F}$}
        \item $\prv$ \textit{replies with $f(\zeta),f(\zeta\omega),q(\zeta)$}
        \item $\vrf$ \textit{checks}
        \begin{enumerate}
            \item $w(\zeta)=q(\zeta)\cdot(\zeta^n-1)$
            \item $f(\zeta),f(\zeta\omega),q(\zeta)$ \textit{are the correct evaluations}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

\subsection{Batched opening with zero-knowledge extension ($\open$)}
\label{sec:kgzzkp}


To efficiently prove several polynomials are vanishing at several points, there are some batched KZG opening schemes such as the schemes in \cite{plonk,bdfg,fflonk}. Although a PCS does not reveal the committed polynomial directly, it leaks the information of the opening evaluation point. In our scenario, each evaluation is privacy-sensitive so we want to hide the polynomial evaluations. We use the opening scheme from \cite{plonk} and the protocol from \cite{rangeproof} with a zero-knowledge extension to explain how to prove the range-proof polynomials are vanishing efficiently and in zero-knowledge. \\
\textit{Assume $\prv$ is given $x$ and $\vrf$ is given $[x]_1$, $\prv$ wants to prove $x$ is in $[0,2^k)$:}
\begin{enumerate}
    \item $\prv$ \textit{interpolates the polynomial $f$ using the above range proof}
    \item $\prv$ \textit{generates two random numbers $\omega^{\prime},\omega^{\prime\prime}$ in $\mathbb{F}\setminus{H}$ and another two random numbers $\alpha,\beta$ in $\mathbb{F}$}
    \item $\prv$ \textit{interpolates $f^\prime$ at two more points ${\omega^{\prime},\omega^{\prime\prime}}$ such that}
    \[ f^\prime(\omega^{\prime})=\alpha \]
    \[ f^\prime(\omega^{\prime\prime})=\beta \]
    \item $\prv$ \textit{computes $w_1,w_2,$ and $w_3$ in the above range proof and sends the commitment to $f^\prime$,} $\cm_{f^\prime}$
    \item $\vrf$ \textit{sends a random challenge $\gamma\in\mathbb{F}$}
    \item $\prv$ \textit{sends the commitment to $q_w:=w/(X^n-1)$ where}
    \[ w:=w_1+\gamma\cdot{w_2}+\gamma^2\cdot{w_3} \]
    \item $\vrf$ \textit{sends a random evaluation point $\zeta\in\mathbb{F}\setminus{H}$}
    \item $\prv$ \textit{sends the evaluations $f(\zeta),f(\zeta\omega),q_w(\zeta)$}
    \item $\prv$ \textit{sends the commitments to $q_1(X),q_2(X)$, where}
    \[ q_1(X):=\frac{f(X)-f(\zeta)}{X-\zeta}+\gamma\cdot\frac{q_w(X)-q_w(\zeta)}{X-\zeta} \]
    \[ q_2(X):=\frac{f(X)-f(\zeta\omega)}{X-\zeta\omega} \]
    \item $\vrf$ \textit{chooses random $r\in\mathbb{F}$}
    \item $\vrf$ \textit{accepts the proof if and only if}
    \begin{enumerate}
    	\item $w_1(\zeta)+\gamma\cdot{w_2(\zeta)}+\gamma^2\cdot{w_3(\zeta)}=q_w(\zeta)\cdot(\zeta^n-1)$
    	\item $e(F+\zeta\cdot\cm_{q_1}+r\zeta\cdot\cm_{q_2},[1]_2)=e(\cm_{q_1}+r\cdot\cm_{q_2},[x]_2)$\textit{, where}
    	\begin{align*}
    		F:=&\cm_f-[f(\zeta)]_1+\gamma\cdot(\cm_{q_w}-[q_w(\zeta)]_1)da+r\cdot(\cm_f-[f(\zeta\omega)]_1)
    	\end{align*}
    \end{enumerate}
%    \item $\prv$ \textit{interpolates a polynomial $g$ such that $g(\tau)=f(\tau),g(\tau\omega)=f(\tau\omega)$ and sends $g$}
%    \item $\prv$ \textit{sends the commitment to $q_{w^\prime}:=w^\prime/(X^n-1)$, where}
%    \begin{align*}
%    	w^\prime:=&(f(X)-g(X))\cdot\frac{X^n-1}{(X-\tau)(X-\tau\omega)}
%    \end{align*}
%    \item $\vrf$ \textit{sends another random evaluation point $\rho\in\mathbb{F}$}
%    \item $\prv$ \textit{sends the commitment to $q_{\hat{w}}:=\hat{w}/(x-\rho)$, where}
%    \begin{align*}
%    	\hat{w}:=&(f(X)-g(\rho))\cdot\frac{\rho^n-1}{(\rho-\tau)(\rho-\tau\omega)}-q_{w^\prime}(X)\cdot(\rho^n-1)
%    \end{align*}
%    \textit{Note $\hat{w}$ is a zero polynomial for all $x\in\mathbb{F}$, which means $X-\rho$ divides $\hat{w}$}
%    \item $\vrf$ \textit{accepts the proof if and only if}
%    	\begin{enumerate}
%    		\item $w_1(\tau)+\gamma\cdot{w_2(\tau)}+\gamma^2\cdot{w_3(\tau)}=q_w(\tau)\cdot(\tau^n-1)$
%    		\item $g(\tau)=f(\tau),g(\tau\omega)=f(\tau\omega)$
%    		\item \textit{$e(F,[1]_2)=e([q_{\hat{w}}]_1,[x-\rho]_2)$, where}
%	    		\begin{align*}
%	    		F:=&(\cm_f-[g(\rho)]_1)\cdot\frac{\rho^n-1}{(\rho-\tau)(\rho-\tau\omega)}-[q_{\hat{w}}]_1\cdot(\rho^n-1)
%	    		\end{align*}
%    	\end{enumerate}
\end{enumerate}

We prove the protocol has zero knowledge. \\
\textit{Let $\mathcal{S}$ generate $\{\omega_i^\prime,\omega_i^{\prime\prime},\alpha_i,\beta_i\},i\in[0,m]$ and interpolate $\{f_i\}$ such that}
\[ f_i(\omega_i^\prime)=\alpha_i \]
\[ f_i(\omega_i^{\prime\prime})=\beta_i \]
\[ f_i(\omega^i)=0 \]
\textit{where $i\in[0,m]$ and $\omega$ is the root of unity in $H$. Note} $\vrf$ \textit{can interact with $\mathcal{S}$ to execute the protocol and accept the proof from $\mathcal{S}$. Given $\{\omega_i^\prime,\omega_i^{\prime\prime},\alpha_i,\beta_i\}_{i\in[0,m]}$ are chosen uniformly at random each time,} $\vrf$ \textit{cannot distinguish between the transcript from $\mathcal{S}$ and the proof from} $\prv$. \textit{Therefore, the protocol has zero knowledge. We will use} $\open$ \textit{to denote this opening technique.}

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =