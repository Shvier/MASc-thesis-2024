\begin{table}[t]
\centering
    \begin{tabular}{|c|c|c|c|} 
        \hline
        \multicolumn{4}{|c|}{$\pi_\mathsf{keys}$} \\
        \hline
        \textbf{Scheme} & \textbf{Proving time} & \textbf{Verifying time} & \textbf{Proof size}  \\
        \hline
        \Sys(\textbf{Ours}) & $O(\nkeys^2)$ & $O(\nkeys)$ & $O(\nkeys)$ \\
        \hline
    \end{tabular}
    \begin{tabular}{|c|c|c|c|c|} 
        \hline
        \multicolumn{5}{|c|}{$\pi_\mathsf{assets}$} \\
        \hline
        \multirow{2}{*}{\textbf{Scheme}} & \multirow{2}{*}{\textbf{Proving time}} & \multicolumn{2}{c|}{\textbf{Verifying time}} & \multirow{2}{*}{\textbf{Proof size}} \\
        \cline{3-4}
        & & $\pi_\mathsf{input}$ & $\pi_\mathsf{proof}$ & \\
        \hline
        Provisions\cite{provisions} & $O(\nkeys)$ & N/A & $O(\nkeys)$ & $O(\nkeys)$ \\
        \hline
        Bulletproofs\cite{bulletproofs} & $O(\nkeys)$ & N/A & $O(\nkeys)$ & $O(\log{\nkeys})$  \\
        \hline
        IZPR\cite{izpr} & $O(t\log{t})$ & $O(\nkeys)$ & $O(1)$ & $O(1)$ \\
        \hline
        \Sys(\textbf{Ours}) & $O(\nkeys)$ & $O(\nkeys)$ & $O(1)$ & $O(1)$ \\
        \hline
    \end{tabular}
    \caption{Comparison of this work with prior PoA schemes. $\pi_\mathsf{input}$ is the verifier processes the public inputs before validating the proof; $\pi_\mathsf{proof}$ is the verifier verifies the proof sent by the prover. Notation: $\nkeys$ is the number of keys that the exchange wants to prove. For IZPR\cite{izpr}, $t$ is the throughput of the blockchain (number of addresses which have changed since the last proof).\label{tab:poa}}
\end{table}

\begin{table}[t]
\centering
    \begin{tabular}{|c|c|c|c|c|c|} 
        \hline
        \multirow{2}{*}{\textbf{Scheme}} & \multirow{2}{*}{\textbf{Proving time}} & \multicolumn{2}{c|}{\textbf{Verifying time}} & \multicolumn{2}{c|}{\textbf{Proof size}} \\
        \cline{3-6}
        & & $\pi_\mathsf{users}$ & $\pi_\mathsf{liabilities}$ & $\pi_\mathsf{users}$ & $\pi_\mathsf{liabilities}$ \\
        \hline
        Provisions\cite{provisions} & $O(\nusers)$ & $O(1)$ & $O(\nusers)$ & $O(1)$ & $O(\nusers)$ \\
        \hline
        DAPOL+\cite{dapol} & $O(\nusers\log{\nusers})$ & $O(\log{\nusers})$ & $O(1)$ & $O(\log{\nusers})$ & $O(1)$ \\
        \hline
        SPPPOL\cite{spp} & $O(\log_{\lambda}{\nusers})$ & $O(\log_{\lambda}{\nusers})$ & $O(1)$ & $O(\log_{\lambda}{\nusers})$ & $O(1)$ \\
        \hline
        Notus\cite{notus} & $O(\nusers\log{\nusers})$ & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$ \\
        \hline
        \Sys(\textbf{Ours}) & $O(k\cdot{\nusers})$ & $O(1)$ & $O(k)$ & $O(1)$ & $O(k)$ \\
        \hline
    \end{tabular}
    \caption{Comparison of this work with prior PoL schemes. Notation: $\nusers$ is the number of users, $k$ is the number of bits of the range proof. For SPPPOL \cite{spp}, $\lambda$ is the arity of the Verkle Tree it uses.\label{tab:pol}}
\end{table}